# file: alpega2.py

import argparse
import io
import os
import time
import subprocess
from typing import Optional, List

from playwright.sync_api import sync_playwright, TimeoutError as PWTimeout
from PyPDF2 import PdfReader, PdfWriter

DETAIL_PATH_KEY = "/ls/vsa/servlet/SendungBearbeitung"
SUMATRA_PATH = r"C:\Users\tamolnar\Documents\SumatraPDF-3.5.2-64\SumatraPDF.exe"

def log(m): print(f"[phase2] {m}", flush=True)

# -------------------- CDP connect (robust) --------------------

def connect_over_cdp_with_retry(pw, cdp_url: str, attempts: int = 3, pause_s: float = 0.5):
    last_err = None
    for i in range(1, attempts + 1):
        try:
            b = pw.chromium.connect_over_cdp(cdp_url)
            return b
        except Exception as e:
            last_err = e
            time.sleep(pause_s)
    raise last_err

# -------------------- Context / page helpers --------------------

def get_current_order_page(context) -> Optional[object]:
    for p in context.pages:
        try:
            if not p.is_closed() and DETAIL_PATH_KEY in (p.url or ""):
                return p
        except Exception:
            pass
    return None

def ensure_detail_ready(page):
    page.bring_to_front()
    page.locator("#elmtKopf\\.Geschaeftsfall").wait_for(state="attached", timeout=8000)

def get_sendung_number(page) -> Optional[str]:
    try:
        loc = page.locator("input[name='SendungNrDfue']")
        if loc.count():
            val = loc.first.input_value().strip()
            if val: return val
        val2 = page.locator("div.input-disabled i").first.inner_text().strip()
        return val2 if val2 else None
    except Exception:
        return None

# -------------------- Forwarder detection --------------------

def detect_forwarder(page) -> str:
    legs_tbl = page.locator("#TableLegs")
    text = ""
    if legs_tbl.count() > 0:
        legs_tbl.wait_for(state="visible", timeout=8000)
        text = legs_tbl.inner_text().lower()
    else:
        rows = page.locator("tr.table-list-row--border")
        rows.first.wait_for(state="visible", timeout=8000)
        text = "\n".join(rows.all_text_contents()).lower()

    t = text
    if "fedex" in t: return "FEDEX"
    if "dsv" in t and "air" in t: return "DSV-AIR"
    if "dsv" in t and "road" in t: return "DSV-ROAD"
    if "dhl express" in t: return "DHL-EXP"
    if "maersk" in t: return "MAERSK"
    if "tromp" in t: return "TROMP"
    if any(x in t for x in ["boogard", "boogaard", "vdb"]): return "VDB"
    if any(x in t for x in ["kuehne", "kühne", "kuehne nagel", "kuehne+nagel", "knn"]): return "KNN"
    if "dhl" in t: return "DGF"  # generic -> DGF
    return "UNKNOWN"

# -------------------- Document select + print button --------------------

def select_document(page, value: str):
    sel = page.locator("#elmtLeg\\.DokumenteDokumente")
    sel.wait_for(state="visible", timeout=6000)
    sel.select_option(value=value)
    log(f"Selected document value={value}")

def click_leg_print_button(page):
    sel = page.locator("#elmtLeg\\.DokumenteDokumente")
    sel.wait_for(state="visible", timeout=6000)
    container = sel.locator("xpath=ancestor::td[1]")
    btn = container.locator("#aElmtBtnLegPrint")
    if not btn.count():
        btn = container.locator("#elmtBtnLegPrint")
    if btn.count():
        btn.first.scroll_into_view_if_needed()
        btn.first.click()
        log("Clicked Leg Print button within document area.")
        return
    page.evaluate("() => (typeof clickGuiButton==='function') && clickGuiButton('BtnLegPrint')")
    log("Fallback: invoked clickGuiButton('BtnLegPrint').")

# -------------------- Popup helpers --------------------

def wait_for_first_popup(context, page):
    try:
        popup = page.wait_for_event("popup", timeout=6000)
        log("Popup A detected.")
        return popup
    except PWTimeout:
        before = set(context.pages)
        for _ in range(30):
            time.sleep(0.15)
            after = set(context.pages)
            new_pages = list(after - before)
            if new_pages:
                log("Popup A detected via fallback.")
                return new_pages[0]
        raise RuntimeError("No popup detected after clicking Leg Print.")

def trigger_do_print(popupA) -> bool:
    popupA.bring_to_front()
    try:
        popupA.wait_for_load_state("domcontentloaded", timeout=4000)
    except Exception:
        pass
    try:
        if popupA.evaluate("() => typeof doPrint === 'function'"):
            popupA.evaluate("() => doPrint()")
            log("Called doPrint() in Popup A via JS.")
            return True
    except Exception:
        pass
    try:
        loc = popupA.locator("a[onclick*='doPrint'], a.locale-icon-print, span[title='Print']").first
        if loc.count():
            loc.click()
            log("Clicked toolbar Print in Popup A.")
            return True
    except Exception:
        pass
    log("Could not trigger doPrint() in Popup A.")
    return False

def wait_for_label_view_after_do_print(context, popupA, timeout_ms=6000):
    try:
        popupB = popupA.wait_for_event("popup", timeout=timeout_ms)
        try: popupB.wait_for_load_state("load", timeout=timeout_ms)
        except: pass
        return popupB
    except Exception:
        pass

    before = set(context.pages)
    for _ in range(int(timeout_ms/150)):
        time.sleep(0.15)
        after = set(context.pages)
        new_pages = list(after - before)
        if new_pages:
            popupB = new_pages[0]
            try: popupB.wait_for_load_state("load", timeout=timeout_ms)
            except: pass
            return popupB

    # Some viewers render inline on Popup A
    return popupA

# -------------------- Kiosk printing (generic forwarders) --------------------

def print_all_copies(label_page, copies: int):
    for _ in range(copies):
        ok = False
        try:
            label_page.evaluate("() => window.print && window.print()")
            ok = True
        except Exception:
            for f in label_page.frames:
                if f == label_page.main_frame: continue
                try:
                    f.evaluate("() => window.print && window.print()")
                    ok = True
                    break
                except:
                    continue
        if not ok:
            log("Warning: window.print() failed on label page.")
        time.sleep(0.30)  # small gap for kiosk queue
    log(f"Requested {copies} copy/copies (kiosk mode).")

# -------------------- FedEx: doPrint download capture --------------------

def click_do_print_and_get_download(context, popupA, timeout_ms=12000):
    popupA.bring_to_front()
    try:
        popupA.wait_for_load_state("domcontentloaded", timeout=4000)
    except Exception:
        pass

    def _fire_print():
        try:
            if popupA.evaluate("() => typeof doPrint === 'function'"):
                popupA.evaluate("() => doPrint()")
                return True
        except Exception:
            pass
        try:
            loc = popupA.locator("a[onclick*='doPrint'], a.locale-icon-print, span[title='Print']").first
            if loc.count():
                loc.click()
                return True
        except Exception:
            pass
        return False

    # Try popup-level first
    try:
        with popupA.expect_download(timeout=timeout_ms) as dl_info:
            _fire_print()
        return dl_info.value
    except PWTimeout:
        pass
    except Exception:
        pass

    # Fallback: context-level
    try:
        with context.expect_event("download", timeout=timeout_ms) as ev_info:
            _fire_print()
        return ev_info.value
    except PWTimeout:
        return None
    except Exception:
        return None

# -------------------- Split & PRINT (Sumatra) for FedEx --------------------

def split_pdf_ranges(pdf_bytes: bytes, ranges: List[List[int]]) -> List[Optional[bytes]]:
    outs = []
    reader = PdfReader(io.BytesIO(pdf_bytes))
    total = len(reader.pages)
    for start, end in ranges:
        s = max(1, start); e = min(total, end)
        if s > e:
            outs.append(None)
            continue
        writer = PdfWriter()
        for p in range(s-1, e):
            writer.add_page(reader.pages[p])
        bio = io.BytesIO()
        writer.write(bio)
        outs.append(bio.getvalue())
    return outs

def silent_print(pdf_path, copies=1):
    for _ in range(copies):
        try:
            subprocess.run(
                [
                    SUMATRA_PATH,
                    "-print-to-default",
                    "-print-settings", "noscale,duplexmode=Simplex",
                    pdf_path
                ],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
                check=False
            )
        except Exception as e:
            log(f"Sumatra print failed: {e}")
        time.sleep(0.15)
    log(f"Sent {copies} copy/copies to printer silently (Simplex).")

def open_data_pdf_and_print(name: str, pdf_bytes: bytes, copies: int):
    tmp_dir = os.path.join(os.getcwd(), "_alpega_tmp")
    os.makedirs(tmp_dir, exist_ok=True)
    path = os.path.join(tmp_dir, f"{name}.pdf")
    with open(path, "wb") as f:
        f.write(pdf_bytes)
    silent_print(path, copies)

# -------------------- FedEx page-range orchestrator --------------------

def fedex_print_with_ranges(context, popupA, dn_number: str):
    log("FedEx: capturing doPrint() download …")
    dl = click_do_print_and_get_download(context, popupA, timeout_ms=12000)
    if not dl:
        log("FedEx: no download captured; aborting FedEx range prints.")
        return

    tmp_dir = os.path.join(os.getcwd(), "_alpega_tmp")
    os.makedirs(tmp_dir, exist_ok=True)
    path_full = os.path.join(tmp_dir, f"{dn_number}_full.pdf")
    dl.save_as(path_full)
    with open(path_full, "rb") as f:
        pdf_bytes = f.read()

    reader = PdfReader(io.BytesIO(pdf_bytes))
    total = len(reader.pages)

    # pages 1–2 (x2)
    part12 = split_pdf_ranges(pdf_bytes, [[1, min(2, total)]])[0]
    if part12:
        open_data_pdf_and_print(f"{dn_number}_pages1-2", part12, copies=2)
    else:
        log("FedEx: document has <1 page? Skipping 1–2 set.")

    # pages 5..end (x1)
    if total >= 5:
        part5n = split_pdf_ranges(pdf_bytes, [[5, total]])[0]
        if part5n:
            open_data_pdf_and_print(f"{dn_number}_pages5-end", part5n, copies=1)
    else:
        log("FedEx: document has <5 pages; skipping 5..end set.")

# -------------------- Cleanup (prevents restart need) --------------------

def cleanup_after_run(context, keep_predicate) -> None:
    """
    Close all pages that do not satisfy `keep_predicate(url)`
    and bring the kept page (main detail) to front.
    """
    kept = None
    for p in list(context.pages):
        try:
            if p.is_closed():
                continue
            url = p.url or ""
            if keep_predicate(url):
                kept = p
                continue
            p.close(run_before_unload=True)  # close popups/preview tabs
        except Exception:
            continue
    if kept:
        try:
            kept.bring_to_front()
        except Exception:
            pass

# -------------------- Placeholder flags (wire later) --------------------

def priority_is_S4() -> bool:
    return False

def is_outside_netherlands() -> bool:
    return False

# -------------------- Main --------------------

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--cdp", default="http://localhost:9222",
                    help="CDP URL for the already-running Edge")
    args = ap.parse_args()

    with sync_playwright() as p:
        # Robust connect (avoid “Timeout 180000ms exceeded” on the 2nd run)
        browser = connect_over_cdp_with_retry(p, args.cdp, attempts=3, pause_s=0.5)

        if not browser.contexts:
            raise RuntimeError("No contexts found. Start Edge with --remote-debugging-port + --kiosk-printing.")
        context = browser.contexts[0]

        page = get_current_order_page(context)
        if not page:
            raise RuntimeError("No open order detail tab found (SendungBearbeitung). Open the order first.")

        log(f"Using current tab: {page.url}")
        ensure_detail_ready(page)

        dn_number = get_sendung_number(page) or "document"
        fwd = detect_forwarder(page)
        log(f"Forwarder: {fwd}")

        # Record pages snapshot — for safety we’ll close anything new we opened.
        initial_pages = set(context.pages)

        def run_doc(value: str, copies: int, fedex_mode: bool = False):
            select_document(page, value)
            click_leg_print_button(page)
            popupA = wait_for_first_popup(context, page)

            if fedex_mode:
                fedex_print_with_ranges(context, popupA, dn_number)
                # Close popup afterwards to avoid sticky state
                try:
                    if not popupA.is_closed(): popupA.close(run_before_unload=True)
                except:
                    pass
            else:
                if not trigger_do_print(popupA):
                    log("Generic: could not trigger doPrint(); skipping.")
                    return
                label_page = wait_for_label_view_after_do_print(context, popupA)
                print_all_copies(label_page, copies)
                # Close label and popup so the next run starts clean
                try:
                    if label_page and not label_page.is_closed():
                        label_page.close(run_before_unload=True)
                except:
                    pass
                try:
                    if not popupA.is_closed():
                        popupA.close(run_before_unload=True)
                except:
                    pass

        # --- Routing ---
        if fwd == "FEDEX":
            run_doc("LABELXXQQXXlabelFedExWeb", copies=1, fedex_mode=True)

        elif fwd == "DSV-AIR":
            run_doc("LABELXXQQXXLabelCarrier", copies=1)
            if priority_is_S4():
                run_doc("LOADINGLSTXXQQXXLoadinglist_empties", copies=2)

        elif fwd == "DSV-ROAD":
            run_doc("LABELXXQQXXLabelCarrier", copies=1)
            run_doc("LOADINGLSTXXQQXXLoadinglist_empties", copies=1)
            if is_outside_netherlands():
                run_doc("LOADINGLSTXXQQXXLoadinglist_CMR_Def_Consol", copies=1)

        elif fwd == "DGF":
            run_doc("LABELXXQQXXLabelCarrier", copies=1)

        elif fwd == "DHL-EXP":
            run_doc("LABELXXQQXXLabelDHL_Web", copies=1)

        elif fwd == "KNN":
            run_doc("LABELXXQQXXLabelCarrier", copies=1)

        elif fwd == "MAERSK":
            run_doc("LABELXXQQXXLabelCarrier", copies=1)

        elif fwd == "TROMP":
            run_doc("LABELXXQQXXLabelCarrier", copies=1)
            run_doc("LOADINGLSTXXQQXXLoadinglist_empties", copies=1)
            if is_outside_netherlands():
                run_doc("LOADINGLSTXXQQXXLoadinglist_CMR_Def_Consol", copies=1)

        elif fwd == "VDB":
            run_doc("LABELXXQQXXLabelCarrier", copies=1)
            run_doc("LOADINGLSTXXQQXXLoadinglist_empties", copies=1)
            if is_outside_netherlands():
                run_doc("LOADINGLSTXXQQXXLoadinglist_CMR_Def_Consol", copies=1)

        else:
            log("Unknown forwarder. No documents printed.")

        log("Done.")

        # Hard cleanup of any pages created in this run (prevents restart need)
        def _keep_pred(url: str) -> bool:
            return (DETAIL_PATH_KEY in (url or ""))
        cleanup_after_run(context, keep_predicate=_keep_pred)

        # IMPORTANT: We intentionally DO NOT close the context/browser here.
        # That keeps the CDP session alive and reusable for the next run.
        log("Leaving browser and context open for reuse.")

if __name__ == "__main__":
    main()