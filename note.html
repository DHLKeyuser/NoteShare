# file: alpega2.py

import argparse
import io
import os
import time
import subprocess
from typing import Optional, List

from playwright.sync_api import sync_playwright, TimeoutError as PWTimeout
from PyPDF2 import PdfReader, PdfWriter

DETAIL_PATH_KEY = "/ls/vsa/servlet/SendungBearbeitung"
SUMATRA_PATH   = r"C:\Users\tamolnar\Documents\SumatraPDF-3.5.2-64\SumatraPDF.exe"
OUT_DIR        = "_alpega_tmp"

def log(m): print(f"[phase2] {m}", flush=True)

# -------------------- CDP connect (robust) --------------------

def connect_over_cdp_with_retry(pw, cdp_url: str, attempts: int = 3, pause_s: float = 0.6):
    err = None
    for _ in range(attempts):
        try:
            return pw.chromium.connect_over_cdp(cdp_url)
        except Exception as e:
            err = e
            time.sleep(pause_s)
    raise err

# -------------------- Context / page helpers --------------------

def get_current_order_page(context) -> Optional[object]:
    for p in context.pages:
        try:
            if not p.is_closed() and DETAIL_PATH_KEY in (p.url or ""):
                return p
        except Exception:
            pass
    return None

def ensure_detail_ready(page):
    page.bring_to_front()
    page.locator("#elmtKopf\\.Geschaeftsfall").wait_for(state="attached", timeout=8000)

def get_sendung_number(page) -> Optional[str]:
    try:
        loc = page.locator("input[name='SendungNrDfue']")
        if loc.count():
            v = loc.first.input_value().strip()
            if v: return v
        v2 = page.locator("div.input-disabled i").first.inner_text().strip()
        return v2 if v2 else None
    except Exception:
        return None

# -------------------- Forwarder detection --------------------

def detect_forwarder(page) -> str:
    legs_tbl = page.locator("#TableLegs")
    if legs_tbl.count() > 0:
        legs_tbl.wait_for(state="visible", timeout=8000)
        t = legs_tbl.inner_text().lower()
    else:
        rows = page.locator("tr.table-list-row--border")
        rows.first.wait_for(state="visible", timeout=8000)
        t = "\n".join(rows.all_text_contents()).lower()

    if "fedex" in t: return "FEDEX"
    if "dsv" in t and "air" in t: return "DSV-AIR"
    if "dsv" in t and "road" in t: return "DSV-ROAD"
    if "dhl express" in t: return "DHL-EXP"
    if "maersk" in t: return "MAERSK"
    if "tromp" in t: return "TROMP"
    if any(x in t for x in ["boogard","boogaard","vdb"]): return "VDB"
    if any(x in t for x in ["kuehne","kühne","kuehne nagel","kuehne+nagel","knn"]): return "KNN"
    if "dhl" in t: return "DGF"
    return "UNKNOWN"

# -------------------- Document select + print button --------------------

def select_document(page, value: str):
    sel = page.locator("#elmtLeg\\.DokumenteDokumente")
    sel.wait_for(state="visible", timeout=6000)
    sel.select_option(value=value)
    log(f"Selected document value={value}")

def click_leg_print_button(page):
    sel = page.locator("#elmtLeg\\.DokumenteDokumente")
    sel.wait_for(state="visible", timeout=6000)
    container = sel.locator("xpath=ancestor::td[1]")
    btn = container.locator("#aElmtBtnLegPrint")
    if not btn.count():
        btn = container.locator("#elmtBtnLegPrint")
    if btn.count():
        btn.first.scroll_into_view_if_needed()
        btn.first.click()
        log("Clicked Leg Print button.")
        return
    page.evaluate("() => (typeof clickGuiButton==='function') && clickGuiButton('BtnLegPrint')")
    log("Fallback: invoked clickGuiButton('BtnLegPrint').")

# -------------------- Popup helpers (reusing same popup if needed) --------------------

def popup_has_print_ui(popup) -> bool:
    try:
        if popup.evaluate("() => typeof doPrint === 'function'"):
            return True
    except Exception:
        pass
    try:
        loc = popup.locator("a[onclick*='doPrint'], a.locale-icon-print, span[title='Print']")
        return loc.count() > 0
    except Exception:
        return False

def wait_for_popup_or_reuse(context, page, existing_popup=None, total_ms=6000):
    """
    After clicking the Leg Print button, Alpega may:
    - open a NEW popup (event fires),
    - or REUSE the existing popup (no 'popup' event). This handles both.
    """
    start = time.time()

    # First try to reuse an existing popup (common for 2nd/3rd print)
    if existing_popup and not existing_popup.is_closed():
        try:
            existing_popup.bring_to_front()
        except Exception:
            pass
        # wait for the print UI to become available
        while (time.time() - start) < (total_ms/1000.0):
            if popup_has_print_ui(existing_popup):
                log("Reused existing popup for this document.")
                return existing_popup
            time.sleep(0.15)

    # Otherwise, wait for a new popup event briefly
    try:
        left = max(0, int(total_ms - (time.time()-start)*1000))
        popup = page.wait_for_event("popup", timeout=left or 1)
        log("Popup A detected (new).")
        return popup
    except PWTimeout:
        pass

    # Fallback: scan for any non-main page that looks like a print popup
    for _ in range(20):
        for p in context.pages:
            if p == page or p.is_closed():
                continue
            try:
                if popup_has_print_ui(p):
                    log("Popup detected via scan (reuse).")
                    return p
            except Exception:
                continue
        time.sleep(0.15)

    raise RuntimeError("No popup detected (new or reused) after clicking Leg Print.")

def trigger_do_print(popupA):
    popupA.bring_to_front()
    try:
        popupA.wait_for_load_state("domcontentloaded", timeout=4000)
    except Exception:
        pass
    try:
        if popupA.evaluate("() => typeof doPrint === 'function'"):
            popupA.evaluate("() => doPrint()")
            log("Called doPrint() in popup.")
            return True
    except Exception:
        pass
    try:
        loc = popupA.locator("a[onclick*='doPrint'], a.locale-icon-print, span[title='Print']").first
        if loc.count():
            loc.click()
            log("Clicked toolbar Print in popup.")
            return True
    except Exception:
        pass
    log("Warning: could not trigger doPrint() (will still try capture paths).")
    return False

# -------------------- PDF capture (download + network sniff + request) --------------------

def _remove_ctx_listener(context, event: str, handler):
    try:
        context.remove_listener(event, handler)  # correct API in Playwright Python
    except Exception:
        pass

def capture_pdf_bytes_after_doprint(context, popupA, timeout_ms=12000) -> Optional[bytes]:
    """
    Obtain PDF bytes after doPrint(), robust across viewers:
      1) popupA.expect_download
      2) context.expect_event('download')
      3) sniff 'application/pdf' responses on the context
      4) request a visible .pdf/DispoPrint URL via context.request
    """
    pdf_bytes = {"data": None}

    def _on_response(resp):
        if pdf_bytes["data"]:
            return
        try:
            ctype = (resp.headers.get("content-type") or "").lower()
            url = (resp.url or "").lower()
            if ("application/pdf" in ctype) or url.endswith(".pdf") or ("dispoprint" in url):
                try:
                    body = resp.body()
                    if body:
                        pdf_bytes["data"] = body
                except Exception:
                    pass
        except Exception:
            pass

    context.on("response", _on_response)

    # Fire print (even if it returns False, keep going to capture any network/pdf)
    trigger_do_print(popupA)

    # 1) popup-level download
    try:
        with popupA.expect_download(timeout=timeout_ms//2) as dl_info:
            pass
        dl = dl_info.value
        tmp = os.path.join(os.getcwd(), OUT_DIR); os.makedirs(tmp, exist_ok=True)
        temp_path = os.path.join(tmp, dl.suggested_filename or "label.pdf")
        dl.save_as(temp_path)
        with open(temp_path, "rb") as f:
            data = f.read()
        _remove_ctx_listener(context, "response", _on_response)
        return data
    except Exception:
        pass

    # 2) context-level download
    try:
        with context.expect_event("download", timeout=timeout_ms//2) as ev_info:
            pass
        dl = ev_info.value
        tmp = os.path.join(os.getcwd(), OUT_DIR); os.makedirs(tmp, exist_ok=True)
        temp_path = os.path.join(tmp, dl.suggested_filename or "label.pdf")
        dl.save_as(temp_path)
        with open(temp_path, "rb") as f:
            data = f.read()
        _remove_ctx_listener(context, "response", _on_response)
        return data
    except Exception:
        pass

    # 3) wait briefly for the sniffer
    t0 = time.time()
    while (time.time() - t0) < (timeout_ms / 1000.0):
        if pdf_bytes["data"]:
            _remove_ctx_listener(context, "response", _on_response)
            return pdf_bytes["data"]
        time.sleep(0.08)

    _remove_ctx_listener(context, "response", _on_response)

    # 4) last resort: try fetching a visible PDF URL via context.request
    try:
        url = (popupA.url or "")
        if url and (url.lower().endswith(".pdf") or "dispoprint" in url.lower()):
            resp = context.request.get(url, headers={"Accept":"application/pdf,*/*"})
            if resp.ok and "application/pdf" in (resp.headers.get("content-type","").lower()):
                return resp.body()

        for fr in [popupA.main_frame, *popupA.frames]:
            try:
                el = fr.locator("embed[src$='.pdf'], iframe[src$='.pdf'], object[data$='.pdf']").first
                if el.count():
                    src = el.get_attribute("src")
                    if src:
                        if src.startswith("/"):
                            from urllib.parse import urljoin
                            base = url.split("?")[0]
                            url2 = urljoin(base, src)
                        else:
                            url2 = src
                        resp = context.request.get(url2, headers={"Accept":"application/pdf,*/*"})
                        if resp.ok and "application/pdf" in (resp.headers.get("content-type","").lower()):
                            return resp.body()
            except Exception:
                continue
    except Exception:
        pass

    return None

# -------------------- Sumatra printing helpers --------------------

def silent_print(pdf_path, copies=1):
    for _ in range(copies):
        try:
            subprocess.run(
                [
                    SUMATRA_PATH,
                    "-print-to-default",
                    "-print-settings", "noscale,duplexmode=Simplex",
                    pdf_path
                ],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
                check=False
            )
        except Exception as e:
            log(f"Sumatra print failed: {e}")
        time.sleep(0.12)
    log(f"Sent {copies} copy/copies to printer silently (Simplex).")

def save_bytes(path: str, data: bytes):
    os.makedirs(os.path.dirname(path), exist_ok=True)
    with open(path, "wb") as f:
        f.write(data)

# -------------------- PDF split for FedEx --------------------

def split_pdf_ranges(pdf_bytes: bytes, ranges: List[List[int]]) -> List[Optional[bytes]]:
    outs = []
    reader = PdfReader(io.BytesIO(pdf_bytes))
    total = len(reader.pages)
    for start, end in ranges:
        s = max(1, start); e = min(total, end)
        if s > e:
            outs.append(None)
            continue
        writer = PdfWriter()
        for p in range(s-1, e):
            writer.add_page(reader.pages[p])
        bio = io.BytesIO()
        writer.write(bio)
        outs.append(bio.getvalue())
    return outs

# -------------------- Per-doc runner (ALL Sumatra) --------------------

def run_doc_sumatra(context, page, value: str, dn: str, doc_suffix: str, copies: int,
                    fedex_special: bool=False, last_popup_ref: dict=None):
    """
    last_popup_ref: a dict like {"popup": Page or None}; will reuse when Alpega does not open a new one.
    """
    select_document(page, value)
    click_leg_print_button(page)

    existing = last_popup_ref.get("popup") if last_popup_ref else None
    try:
        popupA = wait_for_popup_or_reuse(context, page, existing_popup=existing, total_ms=7000)
    except Exception as e:
        log(f"{doc_suffix}: {e}")
        return

    # Store for next call
    if last_popup_ref is not None:
        last_popup_ref["popup"] = popupA

    # Always capture bytes (no kiosk printing)
    data = capture_pdf_bytes_after_doprint(context, popupA, timeout_ms=15000)
    if not data:
        log(f"{doc_suffix}: could not obtain PDF; skipping.")
        return

    out_dir = os.path.join(os.getcwd(), OUT_DIR)
    os.makedirs(out_dir, exist_ok=True)

    if fedex_special:
        # FedEx: page ranges
        reader = PdfReader(io.BytesIO(data))
        total  = len(reader.pages)

        # 1–2 (x2)
        part12 = split_pdf_ranges(data, [[1, min(2, total)]])[0]
        if part12:
            p12_path = os.path.join(out_dir, f"{dn}_pages1-2.pdf")
            save_bytes(p12_path, part12)
            silent_print(p12_path, copies=2)
        else:
            log("FedEx: <2 pages; skipping 1–2 set.")

        # 5..end (x1)
        if total >= 5:
            part5n = split_pdf_ranges(data, [[5, total]])[0]
            if part5n:
                p5n_path = os.path.join(out_dir, f"{dn}_pages5-end.pdf")
                save_bytes(p5n_path, part5n)
                silent_print(p5n_path, copies=1)
        else:
            log("FedEx: <5 pages; skipping 5..end set.")
    else:
        out_path = os.path.join(out_dir, f"{dn}_{doc_suffix}.pdf")
        save_bytes(out_path, data)
        silent_print(out_path, copies=copies)

# -------------------- Placeholder flags (wire later) --------------------

def priority_is_S4() -> bool:
    return False

def is_outside_netherlands() -> bool:
    return False

# -------------------- Main --------------------

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--cdp", default="http://localhost:9222", help="CDP URL for already-running Edge")
    args = ap.parse_args()

    with sync_playwright() as p:
        browser = connect_over_cdp_with_retry(p, args.cdp, attempts=3, pause_s=0.6)
        if not browser.contexts:
            raise RuntimeError("No contexts found. Start Edge with --remote-debugging-port=9222.")
        context = browser.contexts[0]

        page = get_current_order_page(context)
        if not page:
            raise RuntimeError("No open order detail tab found (SendungBearbeitung). Open the order first.")
        log(f"Using current tab: {page.url}")
        ensure_detail_ready(page)

        dn  = get_sendung_number(page) or "document"
        fwd = detect_forwarder(page)
        log(f"Forwarder: {fwd}")

        # We'll reuse the same popup across multiple docs if Alpega does that.
        last_popup_ref = {"popup": None}

        # ---- Routing (ALL via Sumatra) ----
        if fwd == "FEDEX":
            run_doc_sumatra(context, page, "LABELXXQQXXlabelFedExWeb", dn, "FedExLabel",
                            copies=1, fedex_special=True, last_popup_ref=last_popup_ref)

        elif fwd == "DSV-AIR":
            run_doc_sumatra(context, page, "LABELXXQQXXLabelCarrier", dn, "CarrierLabel",
                            copies=1, last_popup_ref=last_popup_ref)
            if priority_is_S4():
                run_doc_sumatra(context, page, "LOADINGLSTXXQQXXLoadinglist_empties", dn, "DockLoadingList",
                                copies=2, last_popup_ref=last_popup_ref)

        elif fwd == "DSV-ROAD":
            run_doc_sumatra(context, page, "LABELXXQQXXLabelCarrier", dn, "CarrierLabel",
                            copies=1, last_popup_ref=last_popup_ref)
            run_doc_sumatra(context, page, "LOADINGLSTXXQQXXLoadinglist_empties", dn, "DockLoadingList",
                            copies=1, last_popup_ref=last_popup_ref)
            if is_outside_netherlands():
                run_doc_sumatra(context, page, "LOADINGLSTXXQQXXLoadinglist_CMR_Def_Consol", dn, "CMR_Consol",
                                copies=1, last_popup_ref=last_popup_ref)

        elif fwd == "DGF":
            run_doc_sumatra(context, page, "LABELXXQQXXLabelCarrier", dn, "CarrierLabel",
                            copies=1, last_popup_ref=last_popup_ref)

        elif fwd == "DHL-EXP":
            run_doc_sumatra(context, page, "LABELXXQQXXLabelDHL_Web", dn, "DHL_WebLabel",
                            copies=1, last_popup_ref=last_popup_ref)

        elif fwd == "KNN":
            run_doc_sumatra(context, page, "LABELXXQQXXLabelCarrier", dn, "CarrierLabel",
                            copies=1, last_popup_ref=last_popup_ref)

        elif fwd == "MAERSK":
            run_doc_sumatra(context, page, "LABELXXQQXXLabelCarrier", dn, "CarrierLabel",
                            copies=1, last_popup_ref=last_popup_ref)

        elif fwd == "TROMP":
            run_doc_sumatra(context, page, "LABELXXQQXXLabelCarrier", dn, "CarrierLabel",
                            copies=1, last_popup_ref=last_popup_ref)
            run_doc_sumatra(context, page, "LOADINGLSTXXQQXXLoadinglist_empties", dn, "DockLoadingList",
                            copies=1, last_popup_ref=last_popup_ref)
            if is_outside_netherlands():
                run_doc_sumatra(context, page, "LOADINGLSTXXQQXXLoadinglist_CMR_Def_Consol", dn, "CMR_Consol",
                                copies=1, last_popup_ref=last_popup_ref)

        elif fwd == "VDB":
            run_doc_sumatra(context, page, "LABELXXQQXXLabelCarrier", dn, "CarrierLabel",
                            copies=1, last_popup_ref=last_popup_ref)
            run_doc_sumatra(context, page, "LOADINGLSTXXQQXXLoadinglist_empties", dn, "DockLoadingList",
                            copies=1, last_popup_ref=last_popup_ref)
            if is_outside_netherlands():
                run_doc_sumatra(context, page, "LOADINGLSTXXQQXXLoadinglist_CMR_Def_Consol", dn, "CMR_Consol",
                                copies=1, last_popup_ref=last_popup_ref)

        else:
            log("Unknown forwarder. No documents printed.")

        log("Done. (No tabs/contexts/browsers closed)")

if __name__ == "__main__":
    main()