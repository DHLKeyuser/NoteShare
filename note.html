import os
import re
import time
import json
import ctypes
import logging
import fitz
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

# ─── CONFIG ───────────────────────────────────────────────
DOWNLOADS_FOLDER = os.path.join(os.environ["USERPROFILE"], "Downloads")
FILENAME_REGEX   = re.compile(r"^\d{8}\.pdf$", re.IGNORECASE)

STABLE_POLLS  = 3
POLL_INTERVAL = 0.1
TIMEOUT       = 5.0

EU_COUNTRIES = {
    "AUSTRIA","BELGIUM","BULGARIA","CROATIA","CYPRUS","CZECHIA","CZECH REPUBLIC",
    "DENMARK","ESTONIA","FINLAND","FRANCE","GERMANY","GREECE","HUNGARY","IRELAND",
    "ITALY","LATVIA","LITHUANIA","LUXEMBOURG","MALTA","NETHERLANDS","THE NETHERLANDS",
    "POLAND","PORTUGAL","ROMANIA","SLOVAKIA","SLOVENIA","SPAIN","SWEDEN"
}

FORBIDDEN_PRICES = {0.0, 0.1, 0.11, 0.01}

logging.basicConfig(
    level=logging.DEBUG,
    format="%(asctime)s %(levelname)-8s %(message)s",
    datefmt="%H:%M:%S"
)

# ─── HELPERS ───────────────────────────────────────────────
def extract_text(path: str) -> str:
    doc = fitz.open(path)
    txt = "\n".join(p.get_text("text") for p in doc)
    doc.close()
    return txt.replace("\xa0", " ")  # replace non-breaking spaces

def guess_country_from_sold_to(sold_to: str) -> str:
    if not sold_to:
        return ""
    lines = [ln.strip() for ln in sold_to.splitlines() if ln.strip()]
    country_line = lines[-1].upper()
    return country_line.split(",")[0]  # remove ", R.O.C." etc.

def is_country_in_eu(country_name: str) -> bool:
    return country_name.upper() in EU_COUNTRIES

def parse_invoice(text: str, filename: str) -> dict:
    res = {"file": filename, "issues": []}

    # Sold to block
    sold_to_match = re.search(r"Sold to\s+(.*?)\nDelivery Ship to", text, re.S)
    sold_to_block = sold_to_match.group(1).strip() if sold_to_match else ""
    res["sold_to"] = sold_to_block
    res["sold_to_contains_ASML"] = "ASML" in sold_to_block.upper()
    country = guess_country_from_sold_to(sold_to_block)
    res["sold_to_country"] = country
    res["in_eu"] = is_country_in_eu(country)

    # Document DN
    dn_match = re.search(r"Document\s+(\d{8})", text)
    if dn_match:
        res["document_dn"] = dn_match.group(1)
        if res["document_dn"] != os.path.splitext(filename)[0]:
            res["issues"].append(f"Document: DN {res['document_dn']} ≠ filename {filename}.")
    else:
        res["issues"].append("Document: Missing DN.")

    # Incoterm
    incoterm_match = re.search(r"Incoterms\s+([A-Z]+)", text)
    res["incoterm"] = incoterm_match.group(1) if incoterm_match else ""

    # Currency
    currency_match = re.search(r"Currency:\s*([A-Z]+)", text)
    res["currency"] = currency_match.group(1) if currency_match else ""

    # Items
    items = []
    item_blocks = re.findall(r"(\d{3}\s+\S+[\s\S]*?)(?=(?:\n\d{3}\s)|\nPackaging details|\Z)", text)
    for block in item_blocks:
        seq_match = re.match(r"(\d{3})\s+(\S+)", block)
        if not seq_match:
            continue
        seq, part_number = seq_match.groups()
        qty_match = re.search(r"\n(\d+(?:\.\d+)?)\s+PC", block)
        unit_price_match = re.search(r"\n([\d,]+\.\d{2})\n([\d,]+\.\d{2})", block)
        coo_match = re.search(r"CoO:\s*(\S+)", block)
        ht_matches = re.findall(r"HT:\s*(\d+)", block)

        qty = float(qty_match.group(1)) if qty_match else None
        unit_price = float(unit_price_match.group(1).replace(",", "")) if unit_price_match else None
        line_total = float(unit_price_match.group(2).replace(",", "")) if unit_price_match else None

        item_data = {
            "seq": seq,
            "part_number": part_number,
            "qty": qty,
            "unit": "PC",
            "unit_price": unit_price,
            "line_total": line_total,
            "coo": coo_match.group(1) if coo_match else None,
            "ht_codes": ht_matches,
            "raw": block.strip()
        }
        items.append(item_data)
    res["items"] = items

    # Packaging
    pkg_match = re.search(r"Packaging details\s+Colli\s+Dimensions\s+Weight\s+(\S+)\s+([\d\.]+)\s*x\s*([\d\.]+)\s*x\s*([\d\.]+)\s*M\s+([\d\.]+)\s+KG", text)
    if pkg_match:
        res["packaging"] = {
            "colli": pkg_match.group(1),
            "dims": [float(pkg_match.group(2)), float(pkg_match.group(3)), float(pkg_match.group(4))],
            "weight_kg": float(pkg_match.group(5))
        }
    else:
        res["packaging"] = {}
        res["issues"].append("Packaging: Missing colli/dimensions/weight.")

    # ─── VALIDATIONS ─────────────────────────────────────
    for item in items:
        price_issue = (
            item["unit_price"] in FORBIDDEN_PRICES or
            item["unit_price"] is None or
            (not res["in_eu"] and item["unit_price"] < 1)
        )
        if price_issue:
            res["issues"].append(f"Item {item['seq']} ({item['part_number']}): Invalid unit price {item['unit_price']}.")

        if (res["sold_to_contains_ASML"] or not res["in_eu"]) and not item["coo"]:
            res["issues"].append(f"Item {item['seq']} ({item['part_number']}): Missing CoO.")

        if (res["sold_to_contains_ASML"] or not res["in_eu"]) and len(item["ht_codes"]) < 2:
            res["issues"].append(f"Item {item['seq']} ({item['part_number']}): Fewer than two HT codes (found {len(item['ht_codes'])}).")

    if "packaging" in res and res["packaging"]:
        dims = res["packaging"]["dims"]
        weight = res["packaging"]["weight_kg"]
        if not res["packaging"]["colli"]:
            res["issues"].append("Packaging: Missing colli number.")
        if any(d <= 0 or d > 10 for d in dims):
            res["issues"].append("Packaging: Abnormal dimension size.")
        if weight <= 0 or weight > 1000:
            res["issues"].append("Packaging: Abnormal weight.")
        if weight > 15 and all(d < 0.8 for d in dims):
            res["issues"].append("Packaging: Heavy item in box-sized dimensions.")

    return res

def popup(title: str, msg: str):
    ctypes.windll.user32.MessageBoxW(0, msg, title, 0x30)

def wait_for_stable(path: str) -> bool:
    last, stable = -1, 0
    deadline = time.time() + TIMEOUT
    while time.time() < deadline:
        try:
            sz = os.path.getsize(path)
        except:
            sz = -1
        if sz == last and sz > 0:
            stable += 1
            if stable >= STABLE_POLLS:
                return True
        else:
            stable = 0
            last = sz
        time.sleep(POLL_INTERVAL)
    return False

class Handler(FileSystemEventHandler):
    def __init__(self):
        self._seen = set()

    def _try_process(self, path: str):
        fname = os.path.basename(path)
        if not FILENAME_REGEX.match(fname) or path in self._seen:
            return
        logging.info(f"→ Candidate detected: {fname}")
        if not wait_for_stable(path):
            logging.error(f"File never stabilized: {fname}")
            return
        self._seen.add(path)
        try:
            txt = extract_text(path)
            result = parse_invoice(txt, fname)
            if result["issues"]:
                msg = f"Issues in {fname}:\n\n" + "\n".join(result["issues"])
                popup("Invoice Issues", msg)
                logging.warning(f"{len(result['issues'])} issue(s) in {fname}")
            else:
                logging.info(f"No issues in {fname}")
            logging.debug(json.dumps(result, indent=2))
        except Exception as e:
            logging.exception(f"Error on {fname}: {e}")
            popup("Invoice Error", f"{fname} error:\n{e}")

    def on_created(self, event):
        if not event.is_directory:
            self._try_process(event.src_path)

    def on_moved(self, event):
        if not event.is_directory:
            self._try_process(event.dest_path)

def main():
    if not os.path.isdir(DOWNLOADS_FOLDER):
        logging.error(f"Downloads not found: {DOWNLOADS_FOLDER}")
        return
    obs = Observer()
    obs.schedule(Handler(), DOWNLOADS_FOLDER, recursive=False)
    obs.start()
    logging.info("Watching for 8-digit PDFs in:\n  " + DOWNLOADS_FOLDER)
    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        obs.stop()
    obs.join()

if __name__ == "__main__":
    main()