# file: alpega_phase2_print_attach_edge.py
# usage:
#   Open the order detail tab in Edge (SendungBearbeitung) -> run:
#     python alpega_phase2_print_attach_edge.py
#
# Notes:
# - Attaches to your running Edge (started with --remote-debugging-port=9222 and --kiosk-printing).
# - No Save clicks.
# - Forwarder-specific document selection + print logic.
# - FedEx: pages 1–2 x2, pages 5..end x1 (skips 3–4) via PDF split & silent print.
# - DSV AIR: Carrier Label x1; Dock Loading List x2 if PRIORITY=S4 (placeholder).
# - DSV ROAD: Carrier Label x1; Dock Loading List x1; CMR Consol x1 if OUTSIDE_NL (placeholder).
# - TROMP/VDB mirror DSV ROAD; DGF/KNN/MAERSK: Carrier Label x1; DHL Express: DHL Web Label x1.

import argparse
import base64
import io
import os
import time
from typing import Optional, List

from playwright.sync_api import sync_playwright, TimeoutError as PWTimeout
from PyPDF2 import PdfReader, PdfWriter

DETAIL_PATH_KEY = "/ls/vsa/servlet/SendungBearbeitung"

def log(m): print(f"[phase2] {m}", flush=True)

# ---------- Helpers: page/context ----------

def get_current_order_page(context) -> Optional[object]:
    for p in context.pages:
        try:
            if p.is_closed(): continue
            if DETAIL_PATH_KEY in (p.url or ""):
                return p
        except Exception:
            pass
    return None

def ensure_detail_ready(page):
    page.bring_to_front()
    page.locator("#elmtKopf\\.Geschaeftsfall").wait_for(state="attached", timeout=20000)

# ---------- Forwarder detection (legs table) ----------

def detect_forwarder(page) -> str:
    legs_tbl = page.locator("#TableLegs")
    text = ""
    if legs_tbl.count() > 0:
        legs_tbl.wait_for(state="visible", timeout=20000)
        text = legs_tbl.inner_text().lower()
    else:
        rows = page.locator("tr.table-list-row--border")
        rows.first.wait_for(state="visible", timeout=20000)
        text = "\n".join(rows.all_text_contents()).lower()

    # normalize
    t = text
    if "fedex" in t: return "FEDEX"
    if "dhl express" in t or "dhl express" in t: return "DHL-EXP"
    if "dhl" in t and "express" not in t: return "DGF"  # conservative (you can refine)
    if "dsv" in t and "air" in t: return "DSV-AIR"
    if "dsv" in t and "road" in t: return "DSV-ROAD"
    if "kuehne" in t or "kühne" in t or "kn" in t or "k+N" in t or "k-n" in t or "kuehne+nagel" in t or "kuehne nagel" in t or "knn" in t: return "KNN"
    if "maersk" in t: return "MAERSK"
    if "tromp" in t: return "TROMP"
    if "boogard" in t or "v.d. boogaard" in t or "vdb" in t or "boogaard" in t: return "VDB"

    return "UNKNOWN"

# ---------- Doc selection + correct leg print button ----------

def select_document(page, value: str):
    sel = page.locator("#elmtLeg\\.DokumenteDokumente")
    sel.wait_for(state="visible", timeout=15000)
    sel.select_option(value=value)
    log(f"Selected document value={value}")

def click_leg_print_button(page):
    sel = page.locator("#elmtLeg\\.DokumenteDokumente")
    sel.wait_for(state="visible", timeout=15000)
    container = sel.locator("xpath=ancestor::td[1]")
    btn = container.locator("#aElmtBtnLegPrint")
    if not btn.count():
        btn = container.locator("#elmtBtnLegPrint")
    if btn.count():
        btn.first.scroll_into_view_if_needed()
        btn.first.click()
        log("Clicked Leg Print button within document area.")
        return
    page.evaluate("() => (typeof clickGuiButton==='function') && clickGuiButton('BtnLegPrint')")
    log("Fallback: invoked clickGuiButton('BtnLegPrint').")

# ---------- Popup A (toolbar with doPrint) ----------

def wait_for_first_popup(context, page):
    try:
        popup = page.wait_for_event("popup", timeout=10000)
        log("Popup A (toolbar) opened via event.")
        return popup
    except PWTimeout:
        before = set(context.pages)
        for _ in range(40):
            time.sleep(0.25)
            after = set(context.pages)
            new_pages = list(after - before)
            if new_pages:
                log("Popup A (toolbar) detected via new-tab fallback.")
                return new_pages[0]
        raise RuntimeError("No popup detected after clicking Leg Print.")

def click_do_print_in_popupA(popup):
    popup.bring_to_front()
    try:
        popup.wait_for_load_state("domcontentloaded", timeout=8000)
    except:
        pass
    deadline = time.time() + 5.0
    while time.time() < deadline:
        try:
            has_do_print = popup.evaluate("() => typeof doPrint === 'function'")
            if has_do_print:
                try:
                    popup.evaluate("() => doPrint()")
                    log("Called doPrint() in Popup A via JS.")
                    return True
                except Exception:
                    return True
            # fallback anchor
            try:
                loc = popup.locator("a[onclick*='doPrint'], a.locale-icon-print, span[title='Print']").first
                try:
                    if loc.count():
                        loc.click()
                        log("Clicked toolbar Print in Popup A.")
                        return True
                except Exception:
                    pass
            except Exception:
                pass
        except Exception:
            pass
        time.sleep(0.2)
    log("Could not trigger doPrint() in Popup A within timeout.")
    return False

def wait_for_label_view_after_do_print(context, popupA):
    try:
        popupB = popupA.wait_for_event("popup", timeout=6000)
        log("Popup B (label) opened via event.")
        try: popupB.wait_for_load_state("load", timeout=10000)
        except: pass
        return popupB
    except Exception:
        pass

    before = set(context.pages)
    for _ in range(24):
        time.sleep(0.25)
        after = set(context.pages)
        new_pages = list(after - before)
        if new_pages:
            popupB = new_pages[0]
            log("Popup B (label) detected as a new tab.")
            try: popupB.wait_for_load_state("load", timeout=10000)
            except: pass
            return popupB

    try:
        url = (popupA.url or "").lower()
    except:
        url = ""
    if "pdf" in url or url.endswith(".pdf"):
        log("Label appears to be loaded in Popup A (PDF URL).")
        return popupA

    log("Assuming label loaded in Popup A (no new popup detected).")
    return popupA

# ---------- Generic print (kiosk: always silent) ----------

def print_all_copies(label_page, copies: int):
    for i in range(copies):
        try:
            label_page.evaluate("() => window.print && window.print()")
        except Exception:
            # try printing inside iframes
            for f in label_page.frames:
                if f == label_page.main_frame: continue
                try:
                    f.evaluate("() => window.print && window.print()")
                    break
                except:
                    continue
        time.sleep(0.7)
    log(f"Requested {copies} copy/copies (all pages).")

# ---------- FedEx special: fetch PDF → split → print subsets ----------

def try_fetch_pdf_bytes(label_page) -> Optional[bytes]:
    """
    Try to fetch the PDF content of the current label page from within the browser context.
    Works if the label URL is same-origin or CORS-permitted. Returns bytes or None.
    """
    try:
        url = label_page.url
        if not url: return None
        # Fetch within the page to inherit cookies; return as base64
        b64 = label_page.evaluate(
            """async (u) => {
                try {
                    const resp = await fetch(u, {credentials:'include'});
                    if (!resp.ok) return null;
                    const buf = await resp.arrayBuffer();
                    const arr = new Uint8Array(buf);
                    let bin = '';
                    for (let i=0; i<arr.length; i++) bin += String.fromCharCode(arr[i]);
                    return btoa(bin);
                } catch(e) { return null; }
            }""",
            url
        )
        if not b64: return None
        return base64.b64decode(b64)
    except Exception:
        return None

def split_pdf_ranges(pdf_bytes: bytes, ranges: List[List[int]]) -> List[bytes]:
    """
    ranges: list of [start, end] 1-based inclusive page numbers.
    Returns list of PDF byte blobs matching each range (skips if out of bounds).
    """
    out_blobs = []
    reader = PdfReader(io.BytesIO(pdf_bytes))
    total = len(reader.pages)
    for start, end in ranges:
        s = max(1, start); e = min(total, end)
        if s > e: 
            out_blobs.append(None)
            continue
        writer = PdfWriter()
        for p in range(s-1, e):
            writer.add_page(reader.pages[p])
        bio = io.BytesIO()
        writer.write(bio)
        out_blobs.append(bio.getvalue())
    return out_blobs

def open_data_pdf_and_print(context, name: str, pdf_bytes: bytes, copies: int):
    """
    Save the PDF to a temp file, open file:// in a new tab, and silent-print (kiosk).
    """
    tmp_dir = os.path.join(os.getcwd(), "_alpega_tmp")
    os.makedirs(tmp_dir, exist_ok=True)
    path = os.path.join(tmp_dir, f"{name}.pdf")
    with open(path, "wb") as f:
        f.write(pdf_bytes)

    page = context.new_page()
    page.goto("file:///" + path.replace("\\", "/"), wait_until="load")
    print_all_copies(page, copies)
    # keep tab open briefly to avoid race with print pipeline
    time.sleep(1.2)
    try:
        page.close()
    except:
        pass

def fedex_print_with_ranges(context, label_page):
    """
    FedEx rule:
      - print pages 1–2 twice
      - print pages 5..end once (skip 3–4)
    """
    log("FedEx: trying to fetch and split PDF for page-range printing.")
    pdf_bytes = try_fetch_pdf_bytes(label_page)
    if not pdf_bytes:
        log("FedEx: could not fetch PDF bytes (viewer/CORS blocked). NOT printing to avoid wrong pages.")
        log("Hint: if there is a download button in Popup A/label viewer, we can click it and use that file.")
        return

    # Build blobs for 1–2 and 5..end
    # First we need total page count
    reader = PdfReader(io.BytesIO(pdf_bytes))
    total = len(reader.pages)

    # (1) pages 1–2
    part12 = split_pdf_ranges(pdf_bytes, [[1, min(2, total)]])[0]
    if part12:
        open_data_pdf_and_print(context, "fedex_pages_1_2", part12, copies=2)
    else:
        log("FedEx: document has <1 page? skipping 1–2 set.")

    # (2) pages 5..end (if any)
    if total >= 5:
        part5_end = split_pdf_ranges(pdf_bytes, [[5, total]])[0]
        if part5_end:
            open_data_pdf_and_print(context, "fedex_pages_5_end", part5_end, copies=1)
    else:
        log("FedEx: document has fewer than 5 pages; skipping 5..end set.")

# ---------- Placeholder flags (to integrate later) ----------

def priority_is_S4() -> bool:
    # TODO: replace with your real logic once integrated
    return False

def is_outside_netherlands() -> bool:
    # TODO: replace with your real logic once integrated
    return False

# ---------- Main ----------

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--cdp", default="http://localhost:9222",
                    help="CDP URL for the already-running Edge (started with --remote-debugging-port)")
    args = ap.parse_args()

    with sync_playwright() as p:
        browser = p.chromium.connect_over_cdp(args.cdp)
        if not browser.contexts:
            raise RuntimeError("No contexts found. Start Edge with --remote-debugging-port + --kiosk-printing.")
        context = browser.contexts[0]

        page = get_current_order_page(context)
        if not page:
            raise RuntimeError("No open order detail tab found (SendungBearbeitung). Open the order first.")

        log(f"Using current tab: {page.url}")
        ensure_detail_ready(page)

        fwd = detect_forwarder(page)
        log(f"Forwarder: {fwd}")

        # Routing: select doc(s), open popup, click Print inside, then print per rules
        def run_doc(value: str, copies: int, fedex_mode: bool = False):
            select_document(page, value)
            click_leg_print_button(page)
            popupA = wait_for_first_popup(context, page)
            if not click_do_print_in_popupA(popupA):
                log("Failed to trigger doPrint() in Popup A; skipping.")
                return
            label_page = wait_for_label_view_after_do_print(context, popupA)
            if fedex_mode:
                fedex_print_with_ranges(context, label_page)
            else:
                print_all_copies(label_page, copies)

        if fwd == "FEDEX":
            # FedEx Label with page-range logic
            run_doc("LABELXXQQXXlabelFedExWeb", copies=1, fedex_mode=True)

        elif fwd == "DSV-AIR":
            # Once all pages: Carrier Label
            run_doc("LABELXXQQXXLabelCarrier", copies=1, fedex_mode=False)
            # Twice all pages if priority is S4 (placeholder)
            if priority_is_S4():
                run_doc("LOADINGLSTXXQQXXLoadinglist_empties", copies=2, fedex_mode=False)

        elif fwd == "DSV-ROAD":
            # Carrier Label x1
            run_doc("LABELXXQQXXLabelCarrier", copies=1, fedex_mode=False)
            # Dock Loading List x1
            run_doc("LOADINGLSTXXQQXXLoadinglist_empties", copies=1, fedex_mode=False)
            # CMR Consol x1 if outside NL (placeholder)
            if is_outside_netherlands():
                run_doc("LOADINGLSTXXQQXXLoadinglist_CMR_Def_Consol", copies=1, fedex_mode=False)

        elif fwd == "DGF":
            run_doc("LABELXXQQXXLabelCarrier", copies=1, fedex_mode=False)

        elif fwd == "DHL-EXP":
            run_doc("LABELXXQQXXLabelDHL_Web", copies=1, fedex_mode=False)

        elif fwd == "KNN":
            run_doc("LABELXXQQXXLabelCarrier", copies=1, fedex_mode=False)

        elif fwd == "MAERSK":
            run_doc("LABELXXQQXXLabelCarrier", copies=1, fedex_mode=False)

        elif fwd == "TROMP":
            run_doc("LABELXXQQXXLabelCarrier", copies=1, fedex_mode=False)
            run_doc("LOADINGLSTXXQQXXLoadinglist_empties", copies=1, fedex_mode=False)
            if is_outside_netherlands():
                run_doc("LOADINGLSTXXQQXXLoadinglist_CMR_Def_Consol", copies=1, fedex_mode=False)

        elif fwd == "VDB":
            run_doc("LABELXXQQXXLabelCarrier", copies=1, fedex_mode=False)
            run_doc("LOADINGLSTXXQQXXLoadinglist_empties", copies=1, fedex_mode=False)
            if is_outside_netherlands():
                run_doc("LOADINGLSTXXQQXXLoadinglist_CMR_Def_Consol", copies=1, fedex_mode=False)

        else:
            log("Unknown forwarder. No documents printed.")

        log("Done.")

if __name__ == "__main__":
    main()