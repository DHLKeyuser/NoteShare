import argparse
import base64
import io
import os
import sys
import time
from typing import Optional, List

from playwright.sync_api import sync_playwright, TimeoutError as PWTimeout
from PyPDF2 import PdfReader, PdfWriter

DETAIL_PATH_KEY = "/ls/vsa/servlet/SendungBearbeitung"

def log(m): print(f"[phase2] {m}", flush=True)
def dprint(enabled, m): 
    if enabled: print(f"[debug] {m}", flush=True)

# ---------------------------- context / tab discovery ----------------------------

def find_sendung_page_in_context(ctx, debug=False):
    for j, p in enumerate(ctx.pages):
        try:
            url = p.url or ""
        except Exception:
            url = ""
        dprint(debug, f"  page {j}: {url}")
        if not p.is_closed() and DETAIL_PATH_KEY in url:
            return p
    return None

def get_current_order_page_any_context(browser, debug=False):
    dprint(debug, f"browser has {len(browser.contexts)} context(s)")
    for i, ctx in enumerate(browser.contexts):
        dprint(debug, f"scanning context {i} with {len(ctx.pages)} page(s)")
        p = find_sendung_page_in_context(ctx, debug=debug)
        if p:
            dprint(debug, f"FOUND in context {i}: {p.url}")
            return ctx, p
    # not found → dump everything once
    for i, ctx in enumerate(browser.contexts):
        dprint(debug, f"context {i} pages dump:")
        for j, p in enumerate(ctx.pages):
            try: dprint(debug, f"  {j}: {p.url}")
            except: pass
    return None, None

def ensure_detail_ready(page):
    page.bring_to_front()
    page.locator("#elmtKopf\\.Geschaeftsfall").wait_for(state="attached", timeout=20000)

# ---------------------------- forwarder detection ----------------------------

def detect_forwarder(page) -> str:
    legs_tbl = page.locator("#TableLegs")
    if legs_tbl.count():
        legs_tbl.wait_for(state="visible", timeout=20000)
        t = legs_tbl.inner_text().lower()
    else:
        rows = page.locator("tr.table-list-row--border")
        rows.first.wait_for(state="visible", timeout=20000)
        t = "\n".join(rows.all_text_contents()).lower()

    if "fedex" in t: return "FEDEX"
    if "dsv" in t and "air" in t: return "DSV-AIR"
    if "dsv" in t and "road" in t: return "DSV-ROAD"
    if "dhl express" in t: return "DHL-EXP"
    if "maersk" in t: return "MAERSK"
    if "tromp" in t: return "TROMP"
    if any(x in t for x in ["boogard","boogaard","vdb"]): return "VDB"
    if any(x in t for x in ["kuehne","kühne","kuehne nagel","kuehne+nagel","knn"]): return "KNN"
    if "dhl" in t: return "DGF"
    return "UNKNOWN"

# ---------------------------- document + print button ----------------------------

def select_document(page, value: str):
    sel = page.locator("#elmtLeg\\.DokumenteDokumente")
    sel.wait_for(state="visible", timeout=15000)
    sel.select_option(value=value)
    log(f"Selected document value={value}")

def click_leg_print_button(page):
    sel = page.locator("#elmtLeg\\.DokumenteDokumente")
    sel.wait_for(state="visible", timeout=15000)
    container = sel.locator("xpath=ancestor::td[1]")
    btn = container.locator("#aElmtBtnLegPrint")
    if not btn.count():
        btn = container.locator("#elmtBtnLegPrint")
    if btn.count():
        btn.first.scroll_into_view_if_needed()
        btn.first.click()
        log("Clicked Leg Print button within document area.")
        return
    page.evaluate("() => (typeof clickGuiButton==='function') && clickGuiButton('BtnLegPrint')")
    log("Fallback: invoked clickGuiButton('BtnLegPrint').")

# ---------------------------- popup A (toolbar) ----------------------------

def wait_for_first_popup(context, page):
    try:
        popup = page.wait_for_event("popup", timeout=12000)
        log("Popup A (toolbar) opened via event.")
        return popup
    except PWTimeout:
        before = set(context.pages)
        for _ in range(60):
            time.sleep(0.2)
            after = set(context.pages)
            diff = list(after - before)
            if diff:
                log("Popup A (toolbar) detected via new-tab fallback.")
                return diff[0]
        raise RuntimeError("No popup detected after clicking Leg Print.")

def click_do_print_in_popupA(popup):
    popup.bring_to_front()
    try:
        popup.wait_for_load_state("domcontentloaded", timeout=8000)
    except: pass

    # only try one path successfully to avoid double‑clicking
    try:
        if popup.evaluate("() => typeof doPrint === 'function'"):
            popup.evaluate("() => doPrint()")
            log("Called doPrint() in Popup A via JS.")
            return True
    except: pass

    try:
        loc = popup.locator("a[onclick*='doPrint'], a.locale-icon-print, span[title='Print']").first
        if loc.count():
            loc.click()
            log("Clicked toolbar Print in Popup A.")
            return True
    except: pass

    log("Could not trigger doPrint() in Popup A.")
    return False

def wait_for_label_view_after_do_print(context, popupA):
    # many envs keep same tab; still check for a new popup
    try:
        popupB = popupA.wait_for_event("popup", timeout=4000)
        log("Popup B (label) opened via event.")
        try: popupB.wait_for_load_state("load", timeout=10000)
        except: pass
        return popupB
    except: pass

    try:
        url = (popupA.url or "").lower()
    except: url = ""
    if "pdf" in url or url.endswith(".pdf") or "dispoprint" in url:
        log("Label appears loaded in Popup A.")
        return popupA

    # last fallback: scan context for a new tab opened recently
    before = set(context.pages)
    time.sleep(0.5)
    after = set(context.pages)
    diff = list(after - before)
    if diff:
        return diff[0]

    return popupA

# ---------------------------- generic kiosk print (all pages) ----------------------------

def print_all_copies(label_page, copies: int):
    for _ in range(copies):
        ok = False
        try:
            label_page.evaluate("() => window.print && window.print()"); ok = True
        except:
            for f in label_page.frames:
                if f == label_page.main_frame: continue
                try:
                    f.evaluate("() => window.print && window.print()"); ok = True; break
                except: continue
        if not ok:
            log("Warning: window.print() failed on label page.")
        time.sleep(0.7)
    log(f"Requested {copies} copy/copies (all pages).")

# ---------------------------- PDF acquisition helpers ----------------------------

def try_request_pdf_via_context(context, label_page) -> Optional[bytes]:
    try:
        url = label_page.url
        if not url: return None
        try: ua = label_page.evaluate("() => navigator.userAgent") or "Mozilla/5.0"
        except: ua = "Mozilla/5.0"
        headers = {
            "Accept": "application/pdf,application/octet-stream;q=0.9,*/*;q=0.8",
            "Referer": url,
            "User-Agent": ua,
        }
        resp = context.request.get(url, headers=headers)
        ctype = (resp.headers.get("content-type") or "").lower()
        if not resp.ok or "application/pdf" not in ctype: return None
        return resp.body()
    except: return None

def try_fetch_pdf_bytes_direct(label_page) -> Optional[bytes]:
    try:
        url = label_page.url
        if not url: return None
        b64 = label_page.evaluate("""async (u) => {
            try {
                const r = await fetch(u, {credentials:'include'});
                if (!r.ok) return null;
                const b = await r.arrayBuffer();
                const a = new Uint8Array(b); let s=''; 
                for (let i=0;i<a.length;i++) s += String.fromCharCode(a[i]);
                return btoa(s);
            } catch(e){ return null; }
        }""", url)
        return base64.b64decode(b64) if b64 else None
    except: return None

def try_click_download_and_get_pdf_bytes(label_page) -> Optional[bytes]:
    selectors = [
        "cr-icon-button[aria-label='Download']",
        "cr-icon-button[title='Download']",
        "button[title='Download']","a[title='Download']","span[title='Download']",
        "a:has-text('Download')","a[onclick*='download']","button[onclick*='download']",
        "button#save",
    ]
    try:
        with label_page.expect_download(timeout=8000) as dl_info:
            clicked = False
            for sel in selectors:
                loc = label_page.locator(sel)
                try:
                    if loc.count():
                        loc.first.scroll_into_view_if_needed()
                        label_page.wait_for_timeout(100)
                        try: loc.first.click()
                        except: label_page.evaluate("(el)=>el.click && el.click()", loc.first.element_handle())
                        log(f"Clicked download via selector: {sel}")
                        clicked = True
                        break
                except: continue
            if not clicked:
                log("No visible Download control found in label viewer.")
                return None
        dl = dl_info.value
        tmp = os.path.join(os.getcwd(), "_alpega_tmp"); os.makedirs(tmp, exist_ok=True)
        path = os.path.join(tmp, dl.suggested_filename or "label.pdf")
        dl.save_as(path)
        with open(path,"rb") as f: data = f.read()
        log(f"Downloaded label file: {os.path.basename(path)} ({len(data)} bytes).")
        return data
    except Exception as e:
        log(f"Download attempt failed: {e}")
        return None

def try_capture_pdf_via_reload(label_page, context, timeout_ms=12000) -> Optional[bytes]:
    got = {"b": None}
    def _on_response(resp):
        try:
            ctype = (resp.headers.get("content-type") or "").lower()
            url = (resp.url or "").lower()
            if ("application/pdf" in ctype) or url.endswith(".pdf") or ("dispoprint" in url):
                if resp.request.frame == label_page.main_frame:
                    body = resp.body()
                    if body: got["b"] = body
        except: pass
    label_page.on("response", _on_response)
    if hasattr(label_page,"off"): rm = lambda: label_page.off("response",_on_response)
    elif hasattr(label_page,"remove_listener"): rm = lambda: label_page.remove_listener("response",_on_response)
    else: rm = lambda: None
    try:
        try: label_page.reload(wait_until="load", timeout=timeout_ms)
        except: pass
        t0 = time.time()
        while time.time()-t0 < (timeout_ms/1000):
            if got["b"]: break
            time.sleep(0.1)
        return got["b"]
    finally:
        try: rm()
        except: pass

def fedex_try_download_via_doPrint(popupA) -> Optional[bytes]:
    """Preferred when Edge is set to 'Always download PDF files'."""
    try:
        popupA.bring_to_front()
        try: popupA.wait_for_load_state("domcontentloaded", timeout=6000)
        except: pass
        with popupA.expect_download(timeout=12000) as dl_info:
            # Trigger exactly once (no double calls)
            try:
                if popupA.evaluate("() => typeof doPrint === 'function'"): 
                    popupA.evaluate("() => doPrint()")
                else:
                    loc = popupA.locator("a[onclick*='doPrint'], a.locale-icon-print, span[title='Print']").first
                    if loc.count(): loc.click()
                    else: popupA.evaluate("() => { if (typeof doPrint==='function') doPrint(); }")
            except: pass
        dl = dl_info.value
        tmp = os.path.join(os.getcwd(), "_alpega_tmp"); os.makedirs(tmp, exist_ok=True)
        path = os.path.join(tmp, dl.suggested_filename or "fedex_label.pdf")
        dl.save_as(path)
        with open(path,"rb") as f: data=f.read()
        log(f"FedEx: downloaded label via doPrint: {os.path.basename(path)} ({len(data)} bytes).")
        return data
    except Exception as e:
        log(f"FedEx: doPrint download path not available ({e}).")
        return None

# ---------------------------- split & print helpers ----------------------------

def split_pdf_ranges(pdf_bytes: bytes, ranges: List[List[int]]) -> List[Optional[bytes]]:
    outs = []
    reader = PdfReader(io.BytesIO(pdf_bytes))
    total = len(reader.pages)
    for start, end in ranges:
        s = max(1, start); e = min(total, end)
        if s > e: outs.append(None); continue
        w = PdfWriter()
        for p in range(s-1, e): w.add_page(reader.pages[p])
        bio = io.BytesIO(); w.write(bio); outs.append(bio.getvalue())
    return outs

def open_data_pdf_and_print(context, name: str, pdf_bytes: bytes, copies: int):
    tmp = os.path.join(os.getcwd(), "_alpega_tmp"); os.makedirs(tmp, exist_ok=True)
    path = os.path.join(tmp, f"{name}.pdf")
    with open(path,"wb") as f: f.write(pdf_bytes)
    page = context.new_page()
    page.goto("file:///" + path.replace("\\","/"), wait_until="load")
    print_all_copies(page, copies)
    time.sleep(1.0)
    try: page.close()
    except: pass

# ---------------------------- FedEx orchestrator ----------------------------

def fedex_print_with_ranges(context, label_page, popupA):
    # 0) Preferred: real download via doPrint()
    log("FedEx: trying doPrint() → download.")
    pdf_bytes = fedex_try_download_via_doPrint(popupA)

    # 1) cookie-aware request
    if not pdf_bytes:
        log("FedEx: trying context.request() …")
        pdf_bytes = try_request_pdf_via_context(context, label_page)

    # 2) reload capture
    if not pdf_bytes:
        log("FedEx: trying reload capture …")
        pdf_bytes = try_capture_pdf_via_reload(label_page, context, timeout_ms=15000)

    # 3) in-page fetch
    if not pdf_bytes:
        log("FedEx: trying in-page fetch …")
        pdf_bytes = try_fetch_pdf_bytes_direct(label_page)

    # 4) viewer download control (rare in your env)
    if not pdf_bytes:
        log("FedEx: trying viewer Download control …")
        pdf_bytes = try_click_download_and_get_pdf_bytes(label_page)

    if not pdf_bytes:
        log("FedEx: could not obtain PDF. Stopping FedEx range prints.")
        return

    reader = PdfReader(io.BytesIO(pdf_bytes))
    total = len(reader.pages)
    # 1–2 twice
    part12 = split_pdf_ranges(pdf_bytes, [[1, min(2, total)]])[0]
    if part12: open_data_pdf_and_print(context, "fedex_pages_1_2", part12, copies=2)
    else: log("FedEx: document has <1 page? Skipping 1–2 set.")
    # 5..end once
    if total >= 5:
        part5 = split_pdf_ranges(pdf_bytes, [[5, total]])[0]
        if part5: open_data_pdf_and_print(context, "fedex_pages_5_end", part5, copies=1)
    else:
        log("FedEx: document has <5 pages; skipping 5..end set.")

# ---------------------------- placeholders (wire later) ----------------------------

def priority_is_S4(): return False
def is_outside_netherlands(): return False

# ---------------------------- main ----------------------------

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--cdp", default="http://localhost:9222", help="CDP URL for already-running Edge")
    ap.add_argument("--debug", action="store_true", help="Verbose diagnostics")
    args = ap.parse_args()

    try:
        with sync_playwright() as p:
            dprint(args.debug, f"Connecting to CDP: {args.cdp}")
            browser = p.chromium.connect_over_cdp(args.cdp)
            if not browser.contexts:
                raise RuntimeError("No contexts found. Start Edge with --remote-debugging-port.")

            context, page = get_current_order_page_any_context(browser, debug=args.debug)
            if not page:
                raise RuntimeError("No open order detail tab found (SendungBearbeitung).")

            log(f"Using tab: {page.url}")
            ensure_detail_ready(page)

            fwd = detect_forwarder(page)
            log(f"Forwarder: {fwd}")

            def run_doc(value: str, copies: int, fedex_mode: bool=False):
                select_document(page, value)
                click_leg_print_button(page)
                popupA = wait_for_first_popup(context, page)
                if not click_do_print_in_popupA(popupA):
                    log("Failed to trigger doPrint() in Popup A; skipping.")
                    return
                label_page = wait_for_label_view_after_do_print(context, popupA)
                if fedex_mode:
                    fedex_print_with_ranges(context, label_page, popupA)
                else:
                    print_all_copies(label_page, copies)

            if fwd == "FEDEX":
                run_doc("LABELXXQQXXlabelFedExWeb", copies=1, fedex_mode=True)

            elif fwd == "DSV-AIR":
                run_doc("LABELXXQQXXLabelCarrier", copies=1)
                if priority_is_S4():
                    run_doc("LOADINGLSTXXQQXXLoadinglist_empties", copies=2)

            elif fwd == "DSV-ROAD":
                run_doc("LABELXXQQXXLabelCarrier", copies=1)
                run_doc("LOADINGLSTXXQQXXLoadinglist_empties", copies=1)
                if is_outside_netherlands():
                    run_doc("LOADINGLSTXXQQXXLoadinglist_CMR_Def_Consol", copies=1)

            elif fwd == "DGF":
                run_doc("LABELXXQQXXLabelCarrier", copies=1)

            elif fwd == "DHL-EXP":
                run_doc("LABELXXQQXXLabelDHL_Web", copies=1)

            elif fwd == "KNN":
                run_doc("LABELXXQQXXLabelCarrier", copies=1)

            elif fwd == "MAERSK":
                run_doc("LABELXXQQXXLabelCarrier", copies=1)

            elif fwd == "TROMP":
                run_doc("LABELXXQQXXLabelCarrier", copies=1)
                run_doc("LOADINGLSTXXQQXXLoadinglist_empties", copies=1)
                if is_outside_netherlands():
                    run_doc("LOADINGLSTXXQQXXLoadinglist_CMR_Def_Consol", copies=1)

            elif fwd == "VDB":
                run_doc("LABELXXQQXXLabelCarrier", copies=1)
                run_doc("LOADINGLSTXXQQXXLoadinglist_empties", copies=1)
                if is_outside_netherlands():
                    run_doc("LOADINGLSTXXQQXXLoadinglist_CMR_Def_Consol", copies=1)

            else:
                log("Unknown forwarder. No documents printed.")

            log("Done.")
    except Exception as e:
        import traceback
        print("[phase2] ERROR:", e, flush=True)
        traceback.print_exc()
        sys.exit(1)

if __name__ == "__main__":
    main()